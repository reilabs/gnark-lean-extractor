package extractor

import (
	"bytes"
	"crypto/sha256"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"testing"

	"github.com/reilabs/gnark-lean-extractor/abstractor"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/frontend"
	"github.com/stretchr/testify/assert"
)

// saveOutput can be called once when creating/changing a test to generate
// the reference result
func saveOutput(filename string, testOutput string) {
	f, err := os.Create(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	_, err = f.WriteString(testOutput)
	if err != nil {
		log.Fatal(err)
	}
}

// checkOutput performs a check of the circuit generated by the extractor.
// If the hashes don't match, the circuit generated by the extractor is printed.
func checkOutput(t *testing.T, testOutput string) {
	// I assume tests are executed from the extractor directory
	filename := fmt.Sprintf("../test/%s.lean", t.Name())

	// https://stackoverflow.com/a/66405130
	if _, err := os.Stat(filename); errors.Is(err, os.ErrNotExist) {
		saveOutput(filename, testOutput)
	}

	f, err := os.Open(filename)
	if err != nil {
		log.Fatalf("Error checking test output\n\n%s\n\n%s\n\n", err, testOutput)
	}
	defer f.Close()

	h := sha256.New()
	if _, err := io.Copy(h, f); err != nil {
		log.Fatal(err)
	}

	correctHash := h.Sum(nil)

	h.Reset()
	if _, err := h.Write([]byte(testOutput)); err != nil {
		log.Fatal(err)
	}
	testResultHash := h.Sum(nil)
	if !bytes.Equal(correctHash, testResultHash) {
		t.Logf("This circuit doesn't match the result in the test folder\n\n%s", testOutput)
		t.Fail()
	}
}

// Example: checking slices optimisation
type TwoSlices struct {
	TwoDim   [][]frontend.Variable
}

func (gadget TwoSlices) DefineGadget(api abstractor.API) interface{} {
	return gadget.TwoDim
}

type ThreeSlices struct {
	ThreeDim [][][]frontend.Variable
}

func (gadget ThreeSlices) DefineGadget(api abstractor.API) interface{} {
	return gadget.ThreeDim
}

type SlicesGadget struct {
	TwoDim   [][]frontend.Variable
	ThreeDim [][][]frontend.Variable
}

func (gadget SlicesGadget) DefineGadget(api abstractor.API) interface{} {
	return append(gadget.ThreeDim[0][0], gadget.TwoDim[0]...)
}

type SlicesOptimisation struct {
	Test     frontend.Variable
	Id       []frontend.Variable
	TwoDim   [][]frontend.Variable
	ThreeDim [][][]frontend.Variable
}

func (circuit *SlicesOptimisation) AbsDefine(api abstractor.API) error {
	Call1(api, SlicesGadget{
		TwoDim:   circuit.TwoDim,
		ThreeDim: circuit.ThreeDim,
	})
	Call1(api, SlicesGadget{
		TwoDim:   [][]frontend.Variable{circuit.TwoDim[1], circuit.TwoDim[0]},
		ThreeDim: [][][]frontend.Variable{circuit.ThreeDim[1], circuit.ThreeDim[0]},
	})
	Call1(api, SlicesGadget{
		TwoDim:   [][]frontend.Variable{{circuit.TwoDim[1][1]}, {circuit.TwoDim[1][0]}},
		ThreeDim: [][][]frontend.Variable{circuit.ThreeDim[1], circuit.ThreeDim[0], circuit.ThreeDim[1]},
	})
	Call1(api, SlicesGadget{
		TwoDim:   [][]frontend.Variable{circuit.TwoDim[1], {circuit.TwoDim[1][0], circuit.TwoDim[0][0], circuit.TwoDim[1][1]}},
		ThreeDim: circuit.ThreeDim,
	})
	Call2(api, TwoSlices{
		TwoDim:   circuit.TwoDim,
	})
	Call3(api, ThreeSlices{
		ThreeDim: circuit.ThreeDim,
	})

	return nil
}

func (circuit SlicesOptimisation) Define(api frontend.API) error {
	return abstractor.Concretize(api, &circuit)
}

func TestSlicesOptimisation(t *testing.T) {
	depthOne := 2
	depthTwo := 3
	depthThree := 4
	twoSlice := make([][]frontend.Variable, depthOne)
	for i := 0; i < int(depthOne); i++ {
		twoSlice[i] = make([]frontend.Variable, depthTwo)
	}

	threeSlice := make([][][]frontend.Variable, depthOne)
	for x := 0; x < int(depthOne); x++ {
		threeSlice[x] = make([][]frontend.Variable, depthTwo)
		for y := 0; y < int(depthTwo); y++ {
			threeSlice[x][y] = make([]frontend.Variable, depthThree)
		}
	}

	assignment := SlicesOptimisation{
		Id:       make([]frontend.Variable, depthTwo),
		TwoDim:   twoSlice,
		ThreeDim: threeSlice,
	}
	out, err := CircuitToLean(&assignment, ecc.BN254)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

// Example: Mismatched arguments error
type DeletionProof struct {
	DeletionIndices []frontend.Variable
	PreRoot         frontend.Variable
	IdComms         []frontend.Variable
	MerkleProofs    [][]frontend.Variable

	BatchSize int
	Depth     int
}

func (gadget DeletionProof) DefineGadget(api abstractor.API) interface{} {
	return gadget.PreRoot
}

type DeletionMbuCircuit struct {
	// single public input
	InputHash frontend.Variable `gnark:",public"`

	// private inputs, but used as public inputs
	DeletionIndices []frontend.Variable `gnark:"input"`
	PreRoot         frontend.Variable   `gnark:"input"`
	PostRoot        frontend.Variable   `gnark:"input"`

	// private inputs
	IdComms      []frontend.Variable   `gnark:"input"`
	MerkleProofs [][]frontend.Variable `gnark:"input"`

	BatchSize int
	Depth     int
}

func (circuit *DeletionMbuCircuit) AbsDefine(api abstractor.API) error {
	root := Call(api, DeletionProof{
		DeletionIndices: circuit.DeletionIndices,
		PreRoot:         circuit.PreRoot,
		IdComms:         circuit.IdComms,
		MerkleProofs:    circuit.MerkleProofs,
		BatchSize:       circuit.BatchSize,
		Depth:           circuit.Depth,
	})

	// Final root needs to match.
	api.AssertIsEqual(root, circuit.PostRoot)

	return nil
}

func (circuit DeletionMbuCircuit) Define(api frontend.API) error {
	return abstractor.Concretize(api, &circuit)
}

func TestDeletionMbuCircuit(t *testing.T) {
	batchSize := 2
	treeDepth := 3
	proofs := make([][]frontend.Variable, batchSize)
	for i := 0; i < int(batchSize); i++ {
		proofs[i] = make([]frontend.Variable, treeDepth)
	}

	assignment := DeletionMbuCircuit{
		DeletionIndices: make([]frontend.Variable, batchSize),
		IdComms:         make([]frontend.Variable, batchSize),
		MerkleProofs:    proofs,

		BatchSize: int(batchSize),
		Depth:     int(treeDepth),
	}
	out, err := CircuitToLean(&assignment, ecc.BN254)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

// Example: Gadget with nested array of int
type IntArrayGadget struct {
	In           []frontend.Variable
	Matrix       [2]int
	NestedMatrix [2][2]int
}

func (gadget IntArrayGadget) DefineGadget(api abstractor.API) interface{} {
	r := api.FromBinary(gadget.In...)
	api.Mul(gadget.Matrix[0], gadget.Matrix[1])
	return []frontend.Variable{r, r, r}
}

type AnotherCircuit struct {
	In     []frontend.Variable
	Matrix [2][2]int
}

func (circuit *AnotherCircuit) AbsDefine(api abstractor.API) error {
	r := Call1(api, IntArrayGadget{
		circuit.In,
		circuit.Matrix[0],
		circuit.Matrix,
	})

	api.FromBinary(r[1:3]...)
	api.FromBinary(r[0:2]...)
	api.FromBinary(r...)
	return nil
}

func (circuit AnotherCircuit) Define(api frontend.API) error {
	return abstractor.Concretize(api, &circuit)
}

func TestAnotherCircuit(t *testing.T) {
	m := [2][2]int{
		{0, 36},
		{1, 44},
	}
	assignment := AnotherCircuit{
		In:     make([]frontend.Variable, 4),
		Matrix: m,
	}
	out, err := CircuitToLean(&assignment, ecc.BN254)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

// Example: Gadget that returns a vector
type OptimisedVectorGadget struct {
	In frontend.Variable
}

func (gadget OptimisedVectorGadget) DefineGadget(api abstractor.API) interface{} {
	return api.ToBinary(gadget.In, 3)
}

// Example: ToBinary behaviour and nested Slice
type VectorGadget struct {
	In_1   []frontend.Variable
	In_2   []frontend.Variable
	Nested [][]frontend.Variable
}

func (gadget VectorGadget) DefineGadget(api abstractor.API) interface{} {
	var sum frontend.Variable
	for i := 0; i < len(gadget.In_1); i++ {
		sum = api.Mul(gadget.In_1[i], gadget.In_2[i])
	}
	return []frontend.Variable{sum, sum, sum}
}

type ToBinaryCircuit struct {
	In     frontend.Variable     `gnark:",public"`
	Out    frontend.Variable     `gnark:",public"`
	Double [][]frontend.Variable `gnark:",public"`
}

func (circuit *ToBinaryCircuit) AbsDefine(api abstractor.API) error {
	bin := api.ToBinary(circuit.In, 3)
	bout := api.ToBinary(circuit.Out, 3)

	api.Add(circuit.Double[2][2], circuit.Double[1][1], circuit.Double[0][0])
	api.Mul(bin[1], bout[1])
	d := Call1(api, VectorGadget{circuit.Double[2][:], circuit.Double[0][:], circuit.Double})
	api.Mul(d[2], d[1])

	return nil
}

func (circuit ToBinaryCircuit) Define(api frontend.API) error {
	return abstractor.Concretize(api, &circuit)
}

func TestGadgetExtraction(t *testing.T) {
	dim_1 := 3
	dim_2 := 3
	doubleSlice := make([][]frontend.Variable, dim_1)
	for i := 0; i < int(dim_1); i++ {
		doubleSlice[i] = make([]frontend.Variable, dim_2)
	}
	assignment := VectorGadget{
		In_1:   make([]frontend.Variable, dim_2),
		In_2:   make([]frontend.Variable, dim_2),
		Nested: doubleSlice,
	}
	out, err := GadgetToLean(&assignment, ecc.BN254)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

func TestToBinaryCircuit(t *testing.T) {
	dim_1 := 3
	dim_2 := 3
	doubleSlice := make([][]frontend.Variable, dim_1)
	for i := 0; i < int(dim_1); i++ {
		doubleSlice[i] = make([]frontend.Variable, dim_2)
	}
	assignment := ToBinaryCircuit{Double: doubleSlice}
	out, err := CircuitToLean(&assignment, ecc.BN254)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

// Example: readme circuit
type DummyCircuit struct {
	In_1 frontend.Variable
	In_2 frontend.Variable
	Out  frontend.Variable
}

func (circuit *DummyCircuit) AbsDefine(api abstractor.API) error {
	sum := api.Add(circuit.In_1, circuit.In_2)
	api.AssertIsEqual(sum, circuit.Out)
	return nil
}

func (circuit DummyCircuit) Define(api frontend.API) error {
	return abstractor.Concretize(api, &circuit)
}

func TestDummyCircuit(t *testing.T) {
	assignment := DummyCircuit{}
	out, err := CircuitToLean(&assignment, ecc.BN254)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

// Example: circuit with constant parameter
type ReturnItself struct {
	In_1 []frontend.Variable
	Out  []frontend.Variable
}

func (gadget ReturnItself) DefineGadget(api abstractor.API) interface{} {
	for i := 0; i < len(gadget.In_1); i++ {
		gadget.Out[i] = api.Mul(gadget.In_1[i], gadget.In_1[i])
	}

	return gadget.Out
}

type SliceGadget struct {
	In_1 []frontend.Variable
	In_2 []frontend.Variable
}

func (gadget SliceGadget) DefineGadget(api abstractor.API) interface{} {
	for i := 0; i < len(gadget.In_1); i++ {
		api.Mul(gadget.In_1[i], gadget.In_2[i])
	}

	r := api.FromBinary(gadget.In_1...)
	return r
}

type CircuitWithParameter struct {
	In    frontend.Variable   `gnark:",public"`
	Path  []frontend.Variable `gnark:",public"`
	Tree  []frontend.Variable `gnark:",public"`
	Param int
}

func (circuit *CircuitWithParameter) AbsDefine(api abstractor.API) error {
	D := make([]frontend.Variable, 3)
	for i := 0; i < len(circuit.Path); i++ {
		D = Call1(api, ReturnItself{
			In_1: circuit.Path,
			Out:  D,
		})
		api.AssertIsEqual(D[1], D[2])
	}

	api.FromBinary(circuit.Path...)
	api.FromBinary(D...)
	api.FromBinary(D[1], D[2], D[0])
	api.FromBinary(D[1], 0, D[0])
	api.FromBinary(D[1:3]...)
	bin := api.ToBinary(circuit.In)
	bin = api.ToBinary(circuit.Param)

	dec := api.FromBinary(bin...)
	api.AssertIsEqual(circuit.Param, dec)
	Call(api, SliceGadget{circuit.Path, circuit.Path})

	api.Mul(circuit.Path[0], circuit.Path[0])
	Call(api, SliceGadget{circuit.Tree, circuit.Tree})
	api.AssertIsEqual(circuit.Param, circuit.In)

	return nil
}

func (circuit CircuitWithParameter) Define(api frontend.API) error {
	return abstractor.Concretize(api, &circuit)
}

func TestCircuitWithParameter(t *testing.T) {
	paramValue := 20
	assignment := CircuitWithParameter{Path: make([]frontend.Variable, 3), Tree: make([]frontend.Variable, 2)}
	assignment.Param = paramValue
	assert.Equal(t, assignment.Param, paramValue, "assignment.Param is a const and should be 20.")
	out, err := CircuitToLean(&assignment, ecc.BN254)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

// Example: circuit with arrays and gadget
type DummyHash struct {
	In_1 frontend.Variable
	In_2 frontend.Variable
}

func (gadget DummyHash) DefineGadget(api abstractor.API) interface{} {
	r := api.Mul(gadget.In_1, gadget.In_2)
	return r
}

type MerkleRecover struct {
	Root    frontend.Variable     `gnark:",public"`
	Element frontend.Variable     `gnark:",public"`
	Path    [20]frontend.Variable `gnark:",secret"`
	Proof   [20]frontend.Variable `gnark:",secret"`
}

func (circuit *MerkleRecover) AbsDefine(api abstractor.API) error {
	current := circuit.Element
	for i := 0; i < len(circuit.Path); i++ {
		leftHash := Call(api, DummyHash{current, circuit.Proof[i]})
		rightHash := Call(api, DummyHash{circuit.Proof[i], current})
		current = api.Select(circuit.Path[i], rightHash, leftHash)
	}
	api.AssertIsEqual(current, circuit.Root)

	return nil
}

func (circuit MerkleRecover) Define(api frontend.API) error {
	return abstractor.Concretize(api, &circuit)
}

func TestMerkleRecover(t *testing.T) {
	assignment := MerkleRecover{}
	out, err := CircuitToLean(&assignment, ecc.BN254)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

// Example: circuit with multiple gadgets
type MyWidget struct {
	Test_1 frontend.Variable
	Test_2 frontend.Variable
	Num    uint32
}

func (gadget MyWidget) DefineGadget(api abstractor.API) interface{} {
	sum := api.Add(gadget.Test_1, gadget.Test_2)
	mul := api.Mul(gadget.Test_1, gadget.Test_2)
	r := api.Div(sum, mul)
	api.AssertIsBoolean(gadget.Num)
	return r
}

type MySecondWidget struct {
	Test_1 frontend.Variable
	Test_2 frontend.Variable
	Num    int
}

func (gadget MySecondWidget) DefineGadget(api abstractor.API) interface{} {
	mul := api.Mul(gadget.Test_1, gadget.Test_2)
	snd := Call(api, MyWidget{gadget.Test_1, gadget.Test_2, uint32(gadget.Num)})
	api.Mul(mul, snd)
	return []frontend.Variable{}
}

type TwoGadgets struct {
	In_1 frontend.Variable
	In_2 frontend.Variable
	Num  int
}

func (circuit *TwoGadgets) AbsDefine(api abstractor.API) error {
	sum := api.Add(circuit.In_1, circuit.In_2)
	prod := api.Mul(circuit.In_1, circuit.In_2)
	CallVoid(api, MySecondWidget{sum, prod, circuit.Num})
	return nil
}

func (circuit TwoGadgets) Define(api frontend.API) error {
	return abstractor.Concretize(api, &circuit)
}

func TestTwoGadgets(t *testing.T) {
	assignment := TwoGadgets{Num: 11}
	out, err := CircuitToLean(&assignment, ecc.BN254)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

func TestExtractGadgets(t *testing.T) {
	assignment_1 := DummyHash{}
	assignment_2 := MySecondWidget{Num: 11}
	assignment_3 := MySecondWidget{Num: 9}
	out, err := ExtractGadgets("MultipleGadgets", ecc.BN254, &assignment_1, &assignment_2, &assignment_3)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

func TestExtractGadgetsVectors(t *testing.T) {
	dim_1 := 3
	dim_2 := 3
	doubleSlice := make([][]frontend.Variable, dim_1)
	for i := 0; i < int(dim_1); i++ {
		doubleSlice[i] = make([]frontend.Variable, dim_2)
	}
	assignment_1 := VectorGadget{
		In_1:   make([]frontend.Variable, dim_2),
		In_2:   make([]frontend.Variable, dim_2),
		Nested: doubleSlice,
	}
	assignment_2 := ReturnItself{
		In_1: make([]frontend.Variable, dim_1),
		Out:  make([]frontend.Variable, dim_1),
	}
	assignment_3 := OptimisedVectorGadget{}
	out, err := ExtractGadgets("MultipleGadgetsVectors", ecc.BN254, &assignment_1, &assignment_2, &assignment_3)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}

func TestExtractCircuits(t *testing.T) {
	assignment_1 := TwoGadgets{Num: 11}
	assignment_2 := MerkleRecover{}

	dim_1 := 3
	dim_2 := 3
	doubleSlice := make([][]frontend.Variable, dim_1)
	for i := 0; i < int(dim_1); i++ {
		doubleSlice[i] = make([]frontend.Variable, dim_2)
	}
	assignment_3 := ToBinaryCircuit{Double: doubleSlice}
	assignment_4 := TwoGadgets{Num: 6}
	assignment_5 := TwoGadgets{Num: 6}

	out, err := ExtractCircuits("MultipleCircuits", ecc.BN254, &assignment_3, &assignment_2, &assignment_1, &assignment_4, &assignment_5)
	if err != nil {
		log.Fatal(err)
	}
	checkOutput(t, out)
}
